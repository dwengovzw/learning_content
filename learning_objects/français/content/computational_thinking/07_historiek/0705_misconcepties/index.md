---
available: true
content_location: example-location
content_type: text/markdown
copyright: dwengo
description: "Id\xE9es re\xE7ues"
difficulty: 3
educational_goals:
- id: id
  source: Source
- id: id2
  source: Source2
estimated_time: 1
hruid: ct07_05
keywords:
- ''
language: fr
licence: dwengo
return_value:
  callback_schema:
    att: test
    att2: test2
  callback_url: callback-url-example
skos_concepts:
- http://ilearn.ilabt.imec.be/vocab/curr1/s-computers-en-systemen
target_ages:
- 12
- 13
- 14
- 15
- 16
- 17
- 18
teacher_exclusive: true
title: "Id\xE9es re\xE7ues"
version: 3
---
# Idées reçues

Parfois, des idées reçues refont surface : on rêve que 
* les ordinateurs pourront exécuter toutes les tâches et résoudre tous les problèmes ; 
* qu’en apprenant à programmer on pourra s’attaquer à tous les problèmes ; 
* qu’on peut penser de façon computationnelle sans aucune notion du versant technique des ordinateurs ni des possibilités et limites qui l’accompagnent. 

Les faits suivants montrent que de tels souhaits ne sont pas réalistes. 
* Il y a des dizaines d’années, Alan Turing a déjà montré qu’il existait des problèmes sur lesquels un ordinateur ne pouvait pas donner de réponse. 

> Il a été démontré qu’il n’existe aucun algorithme pour résoudre le soi-disant « Halting problem » (ou « problème de l’arrêt ») : Étant donné un programme informatique et une valeur d’entrée, déterminer si le programme s’arrête après un nombre fini d’étapes avec cette entrée ou non. 

* Il existe des tâches qu’un ordinateur pourrait, en théorie, effectuer, mais qui ne peuvent jamais être réalisées en pratique en raison d’un temps de calcul beaucoup trop long. Ce n’est pas parce qu’on a trouvé un algorithme pour aborder un problème qu’on parvient effectivement à la solution. Pour le soi-disant problème du voyageur de commerce, par exemple, l’algorithme consiste à passer toutes les possibilités en revue une à une. S’il y a trop de possibilités, il faut beaucoup trop de temps pour trouver une solution. Il faut donc attendre un algorithme plus efficace, mais on n’est pas certain qu’il en existe un. Ce que l’on fait alors, c’est utiliser un algorithme qui donne un bon résultat, sans garantie que ce soit la meilleure solution. 

> Problème du voyageur de commerce : On donne un certain nombre de villes et les distances entre elles. Trouver le plus court chemin qui visite chaque ville une seule fois et se termine à la première ville. 

* Les problèmes sociétaux complexes tels que le changement climatique ne peuvent pas être résolus par un ordinateur. L’ordinateur peut toutefois être mobilisé pour mieux comprendre les différents aspects des problèmes, par exemple en visualisant des données, en modélisant des sous-problèmes et en simulant des solutions possibles. 

* La programmation peut aider à parvenir plus rapidement à la solution d’un problème donné. Mais programmer demande de la pratique, et concevoir une solution à un problème ne peut se faire sans connaissance du domaine dans lequel le problème se situe. 

* Un minimum de connaissances techniques sur l’ordinateur est indispensable pour la pensée computationnelle. Il faut en savoir suffisamment sur l’aspect technique pour pouvoir estimer quand un ordinateur peut être utilisé. Le matériel du système informatique dont on dispose a ses limites : la quantité de mémoire, la vitesse du processeur ... et il faut en tenir compte. Un composant matériel défectueux peut faire en sorte qu’un programme informatique ne fonctionne pas correctement. Outre le matériel, le logiciel est également important : par exemple, pour visualiser des données, un logiciel approprié doit être installé sur l’appareil (Denning & Tedre, 2019). En imaginant des solutions à de nouveaux problèmes, on découvre parfois que les systèmes disponibles sont insuffisants et il faut alors en inventer de nouveaux (Aho, 2011).

---

#### Sources

Aho, A. (2011). Ubiquity Symposium: Computation and Computational Thinking. *Ubiquity*, 2011.<br>
Denning, P. & Tedre, M. (2019). *Computational thinking*. États-Unis : MIT Press.