---
hruid: cd_historiek1-v1
version: 3
language: nl
title: "Ontstaan"
description: "Ontstaan"
keywords: [""]
educational_goals: [
    {source: Source, id: id}, 
    {source: Source2, id: id2}
]
copyright: Copyright by Jerro
licence: Licenced by Jerro
content_type: text/markdown
available: true
target_ages: [12, 13, 14]
difficulty: 3
return_value: {
    callback_url: callback-url-example,
    callback_schema: {
        att: test,
        att2: test2
    }
}
content_location: example-location
estimated_time: 1
skos_concepts: [
    'http://ilearn.ilabt.imec.be/vocab/curr1/s-computers-en-systemen'
]
teacher_exclusive: true
---

# Historiek

## Ontstaan
**De wens om sneller en beter te kunnen rekenen, en om zaken te automatiseren, heeft geleid tot het ontstaan van de moderne computer. En gaandeweg in dat proces is het computationeel denken vanuit het wiskundig, logisch, algoritmisch, wetenschappelijk en technisch denken gegroeid tot een aanvullende manier van denken, naast andere denkwijzen. Momenteel is het een essentieel domein binnen de computerwetenschappen.** 

Bij het uitvoeren van eentonige, repetitieve taken maken mensen fouten door verstrooidheid. Rekenfouten zijn niet uit te sluiten bij berekeningen die met de hand worden uitgevoerd. Mensen zijn gaan nadenken over manieren om dit tegen te gaan. 
Al duizenden jaren is men op zoek naar methodes om de ‘menselijke fout’ waar mogelijk te gaan vermijden. Men ontwierp **hulpmiddelen** om te rekenen, men dacht na over machines die specifieke taken zouden kunnen uitvoeren en men bedacht **systemen** die fouten zouden kunnen voorkomen.

Reeds in de oudheid stelden wiskundige Babyloniërs algoritmen op om bepaalde types van meetkundige problemen op te lossen (Burton, 1991). Ook de oude Grieken ontwierpen algoritmes, zoals het algoritme van Euclides om de grootste gemene deler van twee natuur-Reeds in de oudheid stelden wiskundige Babyloniërs algoritmen op om bepaalde types van meetkundige problemen op te lossen (Burton, 1991). Ook de oude Grieken ontwierpen algoritmes, zoals het algoritme van Euclides om de grootste gemene deler van twee natuurlijke getallen te bepalen en de zeef van Eratosthenes om priemgetallen op te sporen. De algoritmes maakten de wiskundige methodes toegankelijk voor minder rekenvaardige mensen. 

> Een algoritme vertaalt een wiskundige redenering naar een stappenplan. 

Het Salamis telbord is een voorbeeld van een hulpmiddel om te rekenen. Het is een groot marmeren tablet (1,49 m x 0,75 m x 4,5 cm) en is de voorloper van het telraam. De positie van de kralen op een telraam bepaalt een getal. Men kan er dus een getal mee ‘representeren’ en zolang de kralen blijven waar ze zijn, is het getal ‘bewaard’ (Riley & Hunt, 2014). Een telraam dat al heel lang bestaat maar dat nog veelvuldig gebruikt wordt, is het Chinees telraam. 
Later bedacht men ook nog hulpmiddelen zoals de rekenliniaal en logaritmetafels. De eerste rekentoestellen waren er pas in de 17e eeuw, en die konden eigenlijk enkel optellen en aftrekken. 

> ‘Geheugen’ en ‘representatie’ die reeds aanwezig zijn bij een telraam, zijn concepten die terugkomen bij de moderne computers. 

Om lange berekeningen te doen ging men in team werken, waarbij de resultaten van de ene computer, een menselijke rekenaar, werden doorgegeven aan een andere rekenaar die dan eerst een tussentijdse controle uitvoerde (Denning & Tedre, 2019). Los van rekenen, maar ook om fouten te vermijden en het tempo op te drijven, voerde men in het begin van de 20ste eeuw in de industrie het fordisme in, het werken aan de lopende band. 

> De opgedane ervaringen rond het tegengaan van fouten, bv. door sequentieel te werken in team, kregen later een aangepaste invulling in de computerprogramma’s. 

In de 17de eeuw bouwde Blaise Pascal een rekentoestel om op te tellen en af te trekken (het zou nog tot de eerste helft van de 20ste eeuw duren dat er rekentoestellen op de markt kwamen die in staat waren om op te tellen, af te trekken, te vermenigvuldigen en te delen). Gottfried Wilhelm Leibniz verbeterde het toestel van Pascal zodat er toch kon vermenigvuldigd worden door een zelfde optelling een juist aantal keer te herhalen (Denning & Tedre, 2019; Riley & Hunt, 2014). 

> De Pascaline was een mechanisch rekentoestel dat niet kon geprogrammeerd worden. De eerste machine die geprogrammeerd kon worden, was een 19de-eeuws weefgetouw (Riley & Hunt, 2014). 

<div class="alert alert-box alert-success">
    <strong>Creatief denkproces</strong><br>
    Nadenken over hoe een team het best berekeningen uitvoert, nadenken over het ontwerp van een hulpmiddel, nadenken over welke taken door een machine uitgevoerd zouden kunnen worden en hoe dergelijke machines gerealiseerd kunnen worden, is niets anders dan computationeel denken. Dit creatief denkproces en de wil om deze ideeën ook te kunnen verwezenlijken leiden tot nieuwe ontwikkelingen in de technologie.<br>
    Uiteindelijk heeft dit geleid tot de ontwikkeling van de moderne computer (Denning & Tedre, 2019). 
</div>

In de 19de eeuw ontwierp Joseph-Marie Jacquard een weefgetouw waarvan het motief in het toestel ‘geprogrammeerd’ werd met (binaire) ponskaarten. Zijn tijdgenoot Charles Babbage bouwde de Difference Engine die logaritmetafels en sinustafels automatisch kon genereren. Erna spendeerde hij jaren aan het ontwikkelen van de Analytical Machine, een meer algemene (mechanische) computer, die hij echter nooit bouwde, maar waarvoor Ada Lovelace wel het eerste computerprogramma publiceerde. 

> Binaire representatie van gegevens is een van de fundamenten van moderne computers. 
> Om de data en de instructies in de machine in te voeren, wilde Babbage ponskaarten gebruiken. 

De grote verdienste van Lovelace is dat ze begreep dat een computer ook andere dingen kan behalve rekenen. Als men bv. muzieknoten kan voorstellen door getallen, dan zou de machine muziek kunnen maken (Wolfram, 2015). 
Zo evolueerden de eenvoudige rekentoestellen uit de 17de eeuw tot de computers die we vandaag kennen. 

> Lovelace prubliceerde een programma om de Bernoulligetallen te berekenen. Het bevatte reeds al de belangrijke principes van een computerprogramma, zoals binaire representatie, input, verwerking, uitvoer, geheugen, sequentie, herhalings- en keuzestructuren (Wolfram, 2015). 
